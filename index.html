<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>TaGra-mini</title>
  <link rel="stylesheet" href="mini_base.css">
</head>
<body>
  <p id="title">TaGra-mini</p>
  <!--キャンバス-->
<div id="workspace">
  <div id="container">
    <div id="canvas-wrapper">
      <!-- drawCanvas はlayer[aI].canvasに。動的に追加する-->
    </div>
    <!-- cursorCanvasを最前面で独立させる-->
    <canvas id="cursorCanvas">カーソルキャンバス</canvas>
  </div>
  <div id="layer-container">
    <button id="add-layer">新規レイヤー</button>
    <button id="add-layer-from-tags">新規レイヤー<br>（タグから）</button>
    <div id="layer-panel"></div>
  </div>

</div>
  <hr>
  <!-- 線の太さ調整スライダー/inputとはユーザーからの入力を受け付けるもの -->
  <div id="brush-size">
    <label for="brush-width">ブラシサイズ:</label>
    <button id="brush-decrease">-</button>
    <input type="range" id="brush-width" min="1" max="20" value="2">
    <button id="brush-increase"> + </button>
    <span id="brush-size-display">2</span>px
  </div>
  <!--消しゴムサイズ/切り替えボタン-->
  <div id="eraser-block">
    <div id="eraser">
      <label for="eraser-width">消しゴムサイズ:</label>
      <button id="eraser-decrease">-</button>
      <input type="range" id="eraser-width" min="1" max="40" value="8">
      <button id="eraser-increase">+</button>
      <span id="eraser-size-display">8</span>px
    </div>
    <button id="mode-toggle">消しゴムに切り替え</button>
  </div>

  <!-- カラーピッカー&不透明度のhtml -->
<div id="color-block">
  <input type="color" id="color-picker" value="#000000" />
  <label for="alpha">不透明度:</label>
    <input type="range" id="alpha" min="0" max="100" value="100">
    <span id="alpha-display">100</span>%<br>
</div>
<div id="undo-redo">
  <button id="undo-button">←取り消し</button>
  <button id="redo-button">やり直し→</button>
</div>
<script>
//Javascriptはbodyの最下部に書く。これはキャンバスとレイヤーのスクリプト
const wrapper = document.getElementById("canvas-wrapper");
const cursorCanvas = document.getElementById("cursorCanvas");
const cursorTools = cursorCanvas.getContext("2d", { willReadFrequently: true });  //読み込み優先
  //ブラシサイズを取得
  const brushWidthSlider = document.getElementById('brush-width');
  const eraserWidthSlider = document.getElementById('eraser-width');
  const brushSizeDisplay = document.getElementById('brush-size-display');
  const eraserSizeDisplay = document.getElementById('eraser-size-display');
  //ボタンを取得
  const brushDecreaseBtn  = document.getElementById('brush-decrease');
  const brushIncreaseBtn  = document.getElementById('brush-increase');
  const eraserDecreaseBtn = document.getElementById('eraser-decrease');
  const eraserIncreaseBtn = document.getElementById('eraser-increase');
  const addLayerBtn = document.getElementById("add-layer");
  const addLayerFTBtn = document.getElementById("add-layer-from-tags");
  const undoButton = document.getElementById("undo-button");
  const redoButton = document.getElementById("redo-button");
  //レイヤーに関連する変数(旧)
  //レイヤーに関連する変数(旧)
  //let layers = [];  //レイヤーというオブジェクトを格納する配列
  //let activeIndex = 0;  //何番目を描画中？

  //描画フラグと座標の初期化
    let isDrawing = false;
    let isErasing = false;

    let lastX = 0;
    let lastY = 0;

class Layer {
  constructor(name) {
    this.name = name;
    this.canvas = document.createElement("canvas");
    this.tools = this.canvas.getContext("2d", { willReadFrequently: true });
    this.visible = true;
  }
}
/* ===================== LayerManager ===================== */
class LayerManager {
  constructor(wrapper) {
    this.wrapper   = wrapper;
    this.layers    = [];
    this.AI        = 0;   // Active Index
    this.nextId    = 1;   // 名前の連番用
    this._dropIndicator = null;  // ドラッグインジケータ
  }

  /* --- 追加 ------------------------------------------------------- */
  addLayer(name = `Layer ${this.nextId++}`, skipHistory = false) {
    const layer = new Layer(name);
    const { clientWidth: w, clientHeight: h } = this.wrapper;

    layer.canvas.width  = w;
    layer.canvas.height = h;
    layer.canvas.style.zIndex   = this.layers.length + 1;
    layer.canvas.style.position = "absolute";
    layer.canvas.style.top      = "0";
    layer.canvas.style.left     = "0";

    this.wrapper.appendChild(layer.canvas);
    applyBrushStyle(layer.tools);

    this.layers.push(layer);
    this.AI = this.layers.length - 1;
    this.renderLayerPanel();

    if (!skipHistory) {
      const idx = this.layers.length - 1;
      appHistory.push({
        undo: () => this.removeLayer(idx, true),
        redo: () => this.addLayer(name, true),
      });
    }
    return layer;
  }

  /* --- 削除 ------------------------------------------------------- */
  removeLayer(index, skipHistory = false) {
    if (this.layers.length <= 1) {
      alert("エラー：レイヤーを0枚にすることはできません。");
      return false;
    }
    const layer = this.layers[index];
    if (!layer) return false;

    const snapshot = {
      name      : layer.name,
      visible   : layer.visible,
      imageData : layer.tools.getImageData(0, 0, layer.canvas.width, layer.canvas.height),
      index,
    };

    if (!skipHistory) {
      appHistory.push({
        undo: () => {
          const l = new Layer(snapshot.name);
          l.visible = snapshot.visible;
          l.canvas.width  = snapshot.imageData.width;
          l.canvas.height = snapshot.imageData.height;
          l.canvas.style.position = "absolute";
          l.canvas.style.top = l.canvas.style.left = "0";
          l.tools.putImageData(snapshot.imageData, 0, 0);
          this.layers.splice(snapshot.index, 0, l);
          this.wrapper.appendChild(l.canvas);
          this.renderZIndex();
          this.AI = snapshot.index;
          this.renderLayerPanel();
        },
        redo: () => this.removeLayer(snapshot.index, true),
      });
    }

    this.wrapper.removeChild(layer.canvas);
    this.layers.splice(index, 1);
    if (index <= this.AI) this.AI = Math.max(0, this.AI - 1);
    this.renderLayerPanel();
    return true;
  }

  /* --- 名前変更 --------------------------------------------------- */
  renameLayer(index, newName, skipHistory = false) {
    const layer = this.layers[index];
    if (!layer || layer.name === newName) return;
    const oldName = layer.name;
    layer.name = newName;
    this.renderLayerPanel();

    if (!skipHistory) {
      appHistory.push({
        undo: () => this.renameLayer(index, oldName, true),
        redo: () => this.renameLayer(index, newName, true),
      });
    }
  }

  /* --- 並べ替え（履歴対応） ------------------------------------- */
  reorderLayer(oldIdx, newIdx, skipHistory = false) {
    if (oldIdx === newIdx) return;
    const layer = this.layers[oldIdx];
    if (!layer) return;

    if (!skipHistory) {
      appHistory.push({
        undo: () => this.reorderLayer(newIdx, oldIdx, true),
        redo: () => this.reorderLayer(oldIdx, newIdx, true),
      });
    }

    this.layers.splice(oldIdx, 1);
    this.layers.splice(newIdx, 0, layer);

    this.AI = this.layers.indexOf(layer);
    this.renderZIndex();
    this.renderLayerPanel();
  }

  /* --- 上下移動（ボタン用） ------------------------------------- */
  moveLayer(index, direction, skipHistory = false) {
    const target = direction === "up" ? index + 1 : index - 1;
    if (target < 0 || target >= this.layers.length) return;
    this.reorderLayer(index, target, skipHistory);
  }

  /* --- 可視/不可視 ------------------------------------------------ */
  toggleVisibility(index) {
    const layer = this.layers[index];
    if (!layer) return;
    layer.visible = !layer.visible;
    layer.canvas.style.display = layer.visible ? "block" : "none";
  }

  /* --- 複製 ------------------------------------------------------- */
  duplicateLayer(index) {
    const original = this.layers[index];
    if (!original) return null;

    const newLayer = new Layer(`${original.name} copy`);
    newLayer.canvas.width  = original.canvas.width;
    newLayer.canvas.height = original.canvas.height;
    newLayer.tools.drawImage(original.canvas, 0, 0);
    newLayer.canvas.style.position = "absolute";
    newLayer.canvas.style.top = newLayer.canvas.style.left = "0";
    newLayer.canvas.style.zIndex = this.layers.length + 1;
    this.wrapper.appendChild(newLayer.canvas);
    applyBrushStyle(newLayer.tools);

    this.layers.push(newLayer);
    this.AI = this.layers.length - 1;
    this.renderLayerPanel();
    return newLayer;
  }

  /* --- アクティブ ------------------------------------------------- */
  getActiveLayer() { return this.layers[this.AI] ?? null; }
  setActive(idx) {
    if (idx < 0 || idx >= this.layers.length) return;
    this.AI = idx;
    updateBrushColor();
    this.updateActiveHighlight();
  }

  /* --- Z-index 再計算 ------------------------------------------- */
  renderZIndex() {
    this.layers.forEach((l, i) => { l.canvas.style.zIndex = i + 1; });
  }

  /* --- レイヤー一覧取得（任意利用） ------------------------------ */
  getLayerList() {
    return this.layers.map((l, i) => ({
      index  : i,
      name   : l.name,
      visible: l.visible ?? true,
      active : i === this.AI,
    }));
  }

  /* --- パネル再描画＋DnD ---------------------------------------- */
  renderLayerPanel() {
    const panel = document.getElementById("layer-panel");
    panel.innerHTML = "";

    // ドロップインジケータ（初回のみ生成）
    if (!this._dropIndicator) {
      const di = document.createElement("div");
      di.className = "drop-indicator";
      di.style.display = "none";
      panel.appendChild(di);
      this._dropIndicator = di;
    }
    const dropIndicator = this._dropIndicator;
    let draggedIdx = null;

    /* ---------- 1. 行生成 ---------- */
    this.layers.forEach((layer, idx) => {
      const item = document.createElement("div");
      item.className   = "layer-item";
      item.dataset.index = idx;
      if (idx === this.AI) item.classList.add("active-layer");
      item.setAttribute("draggable", true);

      // 名前
      const nameSpan = document.createElement("span");
      nameSpan.className = "layer-name";
      nameSpan.textContent = layer.name;
      nameSpan.setAttribute("draggable", false);
      nameSpan.addEventListener("dblclick", e => {
  e.stopPropagation();
  const input = document.createElement("input");
  input.type = "text";
  input.value = layer.name;
  input.className = "rename-input";

  let confirmed = false;

  const finish = ok => {
    if (ok) this.renameLayer(idx, input.value.trim() || layer.name);
    else    this.renderLayerPanel();
    document.removeEventListener("mousedown", cancelIfOutside);
  };

  const cancelIfOutside = ev => {
    if (!input.contains(ev.target)) {
      finish(false);
    }
  };

  input.addEventListener("keydown", ev => {
    if (ev.key === "Enter")  { confirmed = true; finish(true); }
    if (ev.key === "Escape") { confirmed = false; finish(false); }
  });

  input.addEventListener("blur", () => {
    if (confirmed) return; // Enterで確定済なら何もしない
    // 確定前にフォーカス外れたらキャンセル（外クリック含む）
    finish(false);
  });

  document.addEventListener("mousedown", cancelIfOutside);
  nameSpan.replaceWith(input);
  input.focus(); input.select();
});


      // 選択
      item.addEventListener("click", () => { this.setActive(idx); });

      // 削除ボタン
      const del = document.createElement("button");
      del.className = "delete-button";
      del.textContent = "✕";
      del.setAttribute("draggable", false);
      del.addEventListener("click", e => {
        e.stopPropagation();
        this.removeLayer(idx);
      });

      // ドラッグ開始／終了
      item.addEventListener("dragstart", e => {
        draggedIdx = idx;
        item.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", ""); // for Firefox
      });
      item.addEventListener("dragend", () => {
        item.classList.remove("dragging");
        dropIndicator.style.display = "none";
      });

      // 逆順表示
      item.appendChild(nameSpan);
      item.appendChild(del);
      panel.prepend(item);
    });

    /* ---------- 2. ドラッグオーバー ---------- */
    panel.addEventListener("dragover", e => {
      e.preventDefault();
      if (draggedIdx == null) return;

      const tgt = e.target.closest(".layer-item");
      if (!tgt) return;

      const rect = tgt.getBoundingClientRect();
      const before = e.clientY < rect.top + rect.height / 2;

      dropIndicator.style.display = "block";
      panel.insertBefore(dropIndicator, before ? tgt : tgt.nextSibling);

      const rows = Array.from(panel.querySelectorAll(".layer-item, .drop-indicator"));
      const vis  = rows.indexOf(dropIndicator);
      let logical = this.layers.length - 1 - vis;
      if (logical > draggedIdx) logical -= 1;
      dropIndicator.classList.toggle("below", logical > draggedIdx);
    });

    /* ---------- 3. ドロップ ---------- */
    panel.addEventListener("drop", e => {
      e.preventDefault();
      if (draggedIdx == null) return;

      const rows = Array.from(panel.querySelectorAll(".layer-item, .drop-indicator"));
      const vis  = rows.indexOf(dropIndicator);
      let target = this.layers.length - 1 - vis;
      target = Math.min(Math.max(target, 0), this.layers.length - 1);

      this.reorderLayer(draggedIdx, target);
      draggedIdx = null;
      dropIndicator.style.display = "none";
    });

    this.updateActiveHighlight();
  }

  /* --- アクティブ行のハイライト更新 ----------------------------- */
  updateActiveHighlight() {
    const items = document.querySelectorAll("#layer-panel .layer-item");
    const n = this.layers.length;
    items.forEach((row, i) => {
      const logicalIdx = n - 1 - i; // prepend 表示なので反転
      row.classList.toggle("active-layer", logicalIdx === this.AI);
    });
  }
}
/* =================== /LayerManager ====================== */

class DrawManager {
  constructor(wrapper, cursorCanvas, layerManager) {
    this.wrapper       = wrapper;
    this.cursorCanvas  = cursorCanvas;
    this.cursorTools     = cursorCanvas.getContext('2d');
    this.layerManager  = layerManager;

    this.isDrawing = false;
    this.lastX = this.lastY = 0;

    // 「描画前」を保持する変数
    this._beforeImage  = null;

    // イベント登録はコンストラクタで１回だけ
    wrapper.addEventListener('pointerdown',  e => this.onDown(e));
    wrapper.addEventListener('pointermove',  e => this.onMove(e));
    wrapper.addEventListener('pointerup',    e => this.onUp(e));
    wrapper.addEventListener('pointerleave', e => this.onUp(e));
  }

  //座標を wrapper → アクティブキャンバス座標へ変換
  toCanvas(e) {
    const rect = this.wrapper.getBoundingClientRect();
    const scaleX = this.wrapper.clientWidth  ? (this.wrapper.querySelector('canvas').width  / rect.width)  : 1;
    const scaleY = this.wrapper.clientHeight ? (this.wrapper.querySelector('canvas').height / rect.height) : 1;
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top)  * scaleY,
    };
  }

  //pointerdown
  onDown(e) {
    this.isDrawing = true;

    const activeLayer = this.layerManager.getActiveLayer();
    if (activeLayer) {
      const ctx = activeLayer.tools;
      // 描き始め直前の全体イメージを取得
      this.beforeImage = ctx.getImageData(
        0, 0,
        activeLayer.canvas.width,
        activeLayer.canvas.height
      );
    }

    const {x, y} = this.toCanvas(e);
    this.lastX = x; this.lastY = y;
    this.drawDot(x, y);              // クリック点を 1 ドット描く
  }

  //pointermove
  onMove(e) {
    // カーソルプレビュー（省略可）
    this.updateCursorPreview(e);

    if (!this.isDrawing || e.buttons !== 1) return;
    const {x, y} = this.toCanvas(e);

    const tools  = this.layerManager.getActiveLayer().tools;
    const size = isErasing ? +eraserWidthSlider.value : +brushWidthSlider.value;

    tools.lineWidth = size;
    tools.lineCap = tools.lineJoin = 'round';
    tools.beginPath();
    tools.moveTo(this.lastX, this.lastY);
    tools.lineTo(x, y);
    tools.stroke();

    this.lastX = x; this.lastY = y;
  }

  //pointerup, pointerleave
 onUp(e) {
    if (!this.isDrawing) return;
    this.isDrawing = false;

    const activeLayer = this.layerManager.getActiveLayer();
    if (activeLayer && this.beforeImage) {
      const ctx = activeLayer.tools;
      // 描き終わったあとのイメージを取得
      const afterImage = ctx.getImageData(
        0, 0,
        activeLayer.canvas.width,
        activeLayer.canvas.height
      );
      // 履歴に登録
    const snapBefore = this.beforeImage;  // ← 今の状態をローカル変数に保存！
    appHistory.push({
      undo: () => ctx.putImageData(snapBefore, 0, 0),
      redo: () => ctx.putImageData(afterImage,    0, 0)
    });
    this.beforeImage = null;
    }

    // カーソルプレビューのクリア
    this.cursorTools.clearRect(
      0, 0,
      this.cursorCanvas.width,
      this.cursorCanvas.height
    );
  }

  // クリック点を丸で埋める関数（ペン／消しゴム共用）
  drawDot(x, y) {
    const tools  = this.layerManager.getActiveLayer().tools;
    const size = isErasing ? +eraserWidthSlider.value : +brushWidthSlider.value;

    tools.save();
    tools.lineWidth = 0;
    tools.fillStyle = tools.strokeStyle;
    tools.beginPath();
    tools.arc(x, y, size/2, 0, Math.PI*2);
    tools.fill();
    tools.restore();
  }

  //カーソルプレビュー
  updateCursorPreview(e) {
    const {x, y} = this.toCanvas(e);
    const size = isErasing ? +eraserWidthSlider.value : +brushWidthSlider.value;

    this.cursorTools.clearRect(0,0,this.cursorCanvas.width,this.cursorCanvas.height);
    this.cursorTools.lineWidth = 1;
    this.cursorTools.strokeStyle = 'rgba(0,0,0,0.6)';
    this.cursorTools.beginPath();
    this.cursorTools.arc(x, y, size/2, 0, Math.PI*2);
    this.cursorTools.stroke();
  }
}

class History {
  constructor(limit = 100) {
    this.historyStack   = [];    // { undo: Function, redo: Function } の配列
    this.pointer = -1;    // 現在適用中の操作インデックス
    this.limit   = limit; // 最大保持数
  }

  push(action) {
    if (this.pointer < this.historyStack.length - 1) {
      this.historyStack.splice(this.pointer + 1); // 結果が分岐する
    }
    this.historyStack.push(action);
    if (this.historyStack.length > this.limit) {
      this.historyStack.shift();  // 最初の1つを削除
    } else {
      this.pointer++;
    }
  }

undo() {
  if (this.pointer < 0) {
    console.warn("[Undo] 操作できる履歴がありません。pointer =", this.pointer);
    return;
  }else{
    console.log("undoが実行されました.",appHistory.historyStack);
  }
  this.historyStack[this.pointer].undo();
  this.pointer--;
}

redo() {
  if (this.pointer >= this.historyStack.length - 1) {
    console.warn("[Redo] 戻せる操作がありません。pointer =", this.pointer);
    return;
  }else{
    console.log("redoが実行されました.",appHistory.historyStack);
  }
  this.pointer++;
  this.historyStack[this.pointer].redo();
}
  reset() {
  this.historyStack = [];
  this.pointer = -1;
}

}


function applyBrushStyle(tools){
  tools.lineCap = "round";
  tools.lineJoin = "round";
}
//レイヤーの追加
addLayerBtn.addEventListener("click", () => {
  console.log("add-layer pushed!");
  manager.addLayer()
});
addLayerFTBtn.addEventListener("click", () => {
  console.log("add-layer-from-tags pushed!");
});

// 🎨 ペンの太さ変更
brushWidthSlider.addEventListener('input', () => {
  if (!isErasing) {
    manager.getActiveLayer().tools.lineWidth = brushWidthSlider.value;
  }
  brushSizeDisplay.textContent = brushWidthSlider.value;
});

// 🧽 消しゴムの太さ変更
eraserWidthSlider.addEventListener('input', () => {
  if (isErasing) {
    manager.getActiveLayer().tools.lineWidth = eraserWidthSlider.value;
  }
  eraserSizeDisplay.textContent = eraserWidthSlider.value;
});
//消しゴムモードのスクリプト
const modeToggle = document.getElementById('mode-toggle');
modeToggle.addEventListener('click', () => {
  isErasing = !isErasing;  // 状態を反転true or false
  modeToggle.textContent = isErasing ? "ペンに切り替え" : "消しゴムに切り替え";
  manager.getActiveLayer().tools.globalCompositeOperation = isErasing
    ? 'destination-out'    // ← 消しゴム（trueのとき）
    : 'source-over';       // ← 通常の描画（falseのとき）
  manager.getActiveLayer().tools.lineWidth = isErasing ? eraserWidthSlider.value : brushWidthSlider.value; //モードごとにブラシサイズを定める
});
  //ボタン
  // ブラシサイズ ±1px
brushDecreaseBtn.addEventListener('click', () => {
  let v = parseInt(brushWidthSlider.value, 10); //スライダーの値(文字列)を10進数に変換
  if (v > parseInt(brushWidthSlider.min, 10)) v--;
  brushWidthSlider.value = v;
  brushSizeDisplay.textContent = v;
  if (!isErasing) manager.getActiveLayer().tools.lineWidth = v;
});
brushIncreaseBtn.addEventListener('click', () => {
  let v = parseInt(brushWidthSlider.value, 10);
  if (v < parseInt(brushWidthSlider.max, 10)) v++;
  brushWidthSlider.value = v;
  brushSizeDisplay.textContent = v;
  if (!isErasing) manager.getActiveLayer().tools.lineWidth = v;
});

// 消しゴムサイズ ±1px
eraserDecreaseBtn.addEventListener('click', () => {
  let v = parseInt(eraserWidthSlider.value, 10);
  if (v > parseInt(eraserWidthSlider.min, 10)) v--;
  eraserWidthSlider.value = v;
  eraserSizeDisplay.textContent = v;
  if (isErasing) manager.getActiveLayer().tools.lineWidth = v;
});
eraserIncreaseBtn.addEventListener('click', () => {
  let v = parseInt(eraserWidthSlider.value, 10);
  if (v < parseInt(eraserWidthSlider.max, 10)) v++;
  eraserWidthSlider.value = v;
  eraserSizeDisplay.textContent = v;
  if (isErasing) manager.getActiveLayer().tools.lineWidth = v;
});

//取り消し・やり直し
undoButton.addEventListener("click", (e) => {
  // Ctrl + Z → Undo
    appHistory.undo();
    e.preventDefault();  // ブラウザの元の動作（戻る）を無効化
});
redoButton.addEventListener("click", (e) => {
  // Ctrl + Z → Undo
    appHistory.redo();
    e.preventDefault();  // ブラウザの元の動作（戻る）を無効化
});
  </script>

  <script>// カラーピッカーのスクリプト。
const colorInput = document.getElementById('color-picker');
const alphaInput = document.getElementById('alpha');
const alphaDisplay = document.getElementById('alpha-display');

//初期色設定。カラーコードを16進数から10進数に変案、不透明度と合成してrgbaにした後、

function updateBrushColor() {
  const hex = colorInput.value;
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  const a = alphaInput.value / 100;

  const rgba = `rgba(${r}, ${g}, ${b}, ${a})`;
  //現在アクティブなレイヤーの線色を変更※レイヤーがないとバグるので注意(エラーメッセージ実装を検討)
  manager.getActiveLayer().tools.strokeStyle = rgba;
  //console.log("color changed!");
}

// 色・不透明度の変更イベント
colorInput.addEventListener('input', updateBrushColor);
alphaInput.addEventListener('input', () => {
  alphaDisplay.textContent = alphaInput.value;
  updateBrushColor();
});

//キャンパスサイズを変更するスクリプト。wrapperに依存。フォルダ実装時にいじる必要あり。
function resizeCanvases() {
  const wrapper = document.getElementById('canvas-wrapper');
  const width = wrapper.clientWidth;
  const height = wrapper.clientHeight;

  const canvases = wrapper.querySelectorAll('canvas');
  canvases.forEach(canvas => {
    canvas.width = width;   // 描画解像度の設定（これがないとボケる）
    canvas.height = height;
  });
  cursorCanvas.width = wrapper.clientWidth;
  cursorCanvas.height = wrapper.clientHeight;

}
//この中はhtmlとcssが読み込み終了してから動く


</script>

<!--DOM取得に関わるコード-->
<script>
  appHistory = new History();
  window.addEventListener('load', () => {
  manager = new LayerManager(wrapper);
  baseLayer = manager.addLayer()
  manager.renderLayerPanel();
  resizeCanvases();
  updateBrushColor(); // カラーピッカーの初期化
  appHistory.reset();
  manager.addLayer();
  manager.addLayer();//for test
  DM = new DrawManager(wrapper, cursorCanvas, manager);
});

// キーボードショートカットで undo / redo を実行
window.addEventListener("keydown", e => {
  if (e.ctrlKey && !e.shiftKey && e.key === "z") {
    // Ctrl + Z → Undo
    appHistory.undo();
    e.preventDefault();  // ブラウザの元の動作（戻る）を無効化
  }

  if ((e.ctrlKey && e.key === "y") || (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === "z")) {
    // Ctrl + Y または Ctrl + Shift + Z → Redo
    appHistory.redo();
    e.preventDefault();  // ブラウザの動作（再読み込みなど）を防止
  }
});

</script>
</body>
</html>