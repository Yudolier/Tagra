<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>TaGra-mini</title>
  <link rel="stylesheet" href="mini03_base.css">
  <link rel="stylesheet" href="mini03_layers.css">
  <!-- PickrのテーマCSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css"/>
  <!-- PickrのJS -->
  <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>
</head>
<body>
  <p id="title">TaGra-mini</p>
  <!--キャンバス-->
<div id="workspace">
    <div id="container">
  <div id="canvas-wrapper">
    <!-- drawCanvas はlayer[aI].canvasに。動的に追加する-->
  </div>
  <!-- cursorCanvasを最前面で独立させる-->
  <canvas id="cursorCanvas">カーソルキャンバス</canvas>
</div>
<div id="layer-panel"></div>
</div>
  <hr>
  <!-- 線の太さ調整スライダー/inputとはユーザーからの入力を受け付けるもの -->
  <div id="brush-size">
    <label for="brush-width">ブラシサイズ:</label>
    <button id="brush-decrease">-</button>
    <input type="range" id="brush-width" min="1" max="20" value="2">
    <button id="brush-increase"> + </button>
    <span id="brush-size-display">2</span>px
  </div>
  <!--消しゴムサイズ/切り替えボタン-->
  <div id="eraser-block">
    <div id="eraser">
      <label for="eraser-width">消しゴムサイズ:</label>
      <button id="eraser-decrease">-</button>
      <input type="range" id="eraser-width" min="1" max="40" value="8">
      <button id="eraser-increase">+</button>
      <span id="eraser-size-display">8</span>px
    </div>
    <button id="mode-toggle">消しゴムに切り替え</button>
  </div>

  <!-- カラーピッカー&不透明度のhtml -->
<div id="color-block">
  <input type="color" id="color-picker" value="#000000" />
  <label for="alpha">不透明度:</label>
    <input type="range" id="alpha" min="0" max="100" value="100">
    <span id="alpha-display">100</span>%<br>
</div>

<script>
//Javascriptはbodyの最下部に書く。これはキャンバスとレイヤーのスクリプト
const wrapper = document.getElementById("canvas-wrapper");
const cursorCanvas = document.getElementById("cursorCanvas");
const cursorCtx = cursorCanvas.getContext("2d");
  //ブラシサイズを取得
  const brushWidthSlider = document.getElementById('brush-width');
  const eraserWidthSlider = document.getElementById('eraser-width');
  const brushSizeDisplay = document.getElementById('brush-size-display');
  const eraserSizeDisplay = document.getElementById('eraser-size-display');
  //ボタンを取得
  const brushDecreaseBtn  = document.getElementById('brush-decrease');
  const brushIncreaseBtn  = document.getElementById('brush-increase');
  const eraserDecreaseBtn = document.getElementById('eraser-decrease');
  const eraserIncreaseBtn = document.getElementById('eraser-increase');
  //レイヤーに関連する変数
  let layers = [];  //レイヤーというオブジェクトを格納する配列
  let activeIndex = 0;  //何番目を描画中？
  //描画フラグと座標の初期化
    let isDrawing = false;
    let isErasing = false;

    let lastX = 0;
    let lastY = 0;
//レイヤーをclassにする
//name以外は勝手に決まる（layer.canvasとかで引き出せる）
//Layerはname(という文字列),canvas,ctxからなるオブジェクトになる！
class Layer {
  constructor(name) {
    this.name = name;
    this.canvas = document.createElement("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.visible = true;
  }
}
function addLayer(wrapper, layers) {
  const index = layers.length + 1;  // ← 今から追加されるレイヤー番号 0番目が1
  const layer = new Layer(`Layer ${index}`);  //スコープok!
  layer.canvas.style.zIndex = index;
  wrapper.appendChild(layer.canvas);


    // ★ 追加： wrapper と同じピクセル解像度を設定
    const { clientWidth:w, clientHeight:h } = wrapper;
  layer.canvas.width  = w;
  layer.canvas.height = h;
  layers.push(layer);
  return layer;
}
class LayerManager {
  constructor(wrapper) {
    this.wrapper = wrapper;
    this.cursorCanvas = document.getElementById("cursorCanvas");
    this.layers = [];
    this.AI = 0;
    this.nextId = 1; // 名前が被らないようにする
  }

  addLayer(name = `Layer ${this.nextId++}`) {
    const layer = new Layer(name);
    const { clientWidth: w, clientHeight: h } = this.wrapper;
    layer.canvas.width = w;
    layer.canvas.height = h;
    layer.canvas.style.zIndex = this.layers.length + 1;
    layer.canvas.style.position = "absolute";
    layer.canvas.style.top = "0";
    layer.canvas.style.left = "0";
    this.wrapper.appendChild(layer.canvas);

    applyBrushStyle(layer.ctx);
    setupEvents(layer);
    attachDrawEvents(layer);

    this.layers.push(layer);
    this.AI = this.layers.length - 1;  //レイヤー1のAIは0
    return layer;
  }

  getActiveLayer() {
    return this.layers[this.AI] ?? null;
  }

  setActive(index) {
    if (index >= 0 && index < this.layers.length) {
      this.AI = index;
    }
  }

  removeLayer(index) {
    if (this.layers.length <= 1) {
      alert("レイヤーを0枚にすることはできません。");
      return false;
    }

    const layer = this.layers[index];
    if (!layer) return false;

    detachDrawEvents(layer);  //バグらせないために必要な処理
    this.wrapper.removeChild(layer.canvas);
    this.layers.splice(index, 1);

    if (this.AI >= this.layers.length) {
      this.AI = this.layers.length - 1;
    }

    return true;
  }

  renameLayer(index, newName) {
    const layer = this.layers[index];
    if (layer) {
      layer.name = newName;
    }
  }

  toggleVisibility(index) {
    const layer = this.layers[index];
    if (layer) {
      layer.visible = !layer.visible;
      layer.canvas.style.display = layer.visible ? "block" : "none";
    }
  }

  duplicateLayer(index) {
    const original = this.layers[index];
    if (!original) {
    alert(`指定されたレイヤー（index: ${index}）が見つかりませんでした。複製できません。`);
    console.error(`duplicateLayer: index ${index} が無効です。layers.length = ${this.layers.length}`);
    return null;
  }

    const newLayer = new Layer(`${original.name} copy`);
    newLayer.canvas.width = original.canvas.width;
    newLayer.canvas.height = original.canvas.height;
    newLayer.ctx.drawImage(original.canvas, 0, 0);

    newLayer.canvas.style.zIndex = this.layers.length + 1;
    newLayer.canvas.style.position = "absolute";
    newLayer.canvas.style.top = "0";
    newLayer.canvas.style.left = "0";
    this.wrapper.appendChild(newLayer.canvas);

    applyBrushStyle(newLayer.ctx);
    setupEvents(newLayer);
    attachDrawEvents(newLayer);

    this.layers.push(newLayer);
    this.AI = this.layers.length - 1;
    return newLayer;
  }

  moveLayer(index, direction) {
    const swapWith = direction === "up" ? index + 1 : index - 1;
    if (swapWith < 0 || swapWith >= this.layers.length) return;

    [this.layers[index], this.layers[swapWith]] = [this.layers[swapWith], this.layers[index]];
    this.renderZIndex();
    this.AI = swapWith;
  }

  renderZIndex() {
    this.layers.forEach((layer, i) => {
      layer.canvas.style.zIndex = i + 1;
    });
  }

  getLayerList() {
    return this.layers.map((layer, index) => ({
      index,
      name: layer.name,
      visible: layer.visible ?? true,
      active: index === this.AI,
    }));
  }
}




function applyBrushStyle(ctx){
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
}

// 🎨 ペンの太さ変更
brushWidthSlider.addEventListener('input', () => {
  if (!isErasing) {
    layers[activeIndex].ctx.lineWidth = brushWidthSlider.value;
  }
  brushSizeDisplay.textContent = brushWidthSlider.value;
});

// 🧽 消しゴムの太さ変更
eraserWidthSlider.addEventListener('input', () => {
  if (isErasing) {
    layers[activeIndex].ctx.lineWidth = eraserWidthSlider.value;
  }
  eraserSizeDisplay.textContent = eraserWidthSlider.value;
});
//消しゴムモードのスクリプト
const modeToggle = document.getElementById('mode-toggle');
modeToggle.addEventListener('click', () => {
  isErasing = !isErasing;  // 状態を反転true or false
  modeToggle.textContent = isErasing ? "ペンに切り替え" : "消しゴムに切り替え";
  layers[activeIndex].ctx.globalCompositeOperation = isErasing
    ? 'destination-out'    // ← 消しゴム（trueのとき）
    : 'source-over';       // ← 通常の描画（falseのとき）
  layers[activeIndex].ctx.lineWidth = isErasing ? eraserWidthSlider.value : brushWidthSlider.value; //モードごとにブラシサイズを定める
});
  //ボタン
  // ブラシサイズ ±1px
brushDecreaseBtn.addEventListener('click', () => {
  let v = parseInt(brushWidthSlider.value, 10); //スライダーの値(文字列)を10進数に変換
  if (v > parseInt(brushWidthSlider.min, 10)) v--;
  brushWidthSlider.value = v;
  brushSizeDisplay.textContent = v;
  if (!isErasing) layers[activeIndex].ctx.lineWidth = v;
});
brushIncreaseBtn.addEventListener('click', () => {
  let v = parseInt(brushWidthSlider.value, 10);
  if (v < parseInt(brushWidthSlider.max, 10)) v++;
  brushWidthSlider.value = v;
  brushSizeDisplay.textContent = v;
  if (!isErasing) layers[activeIndex].ctx.lineWidth = v;
});

// 消しゴムサイズ ±1px
eraserDecreaseBtn.addEventListener('click', () => {
  let v = parseInt(eraserWidthSlider.value, 10);
  if (v > parseInt(eraserWidthSlider.min, 10)) v--;
  eraserWidthSlider.value = v;
  eraserSizeDisplay.textContent = v;
  if (isErasing) layers[activeIndex].ctx.lineWidth = v;
});
eraserIncreaseBtn.addEventListener('click', () => {
  let v = parseInt(eraserWidthSlider.value, 10);
  if (v < parseInt(eraserWidthSlider.max, 10)) v++;
  eraserWidthSlider.value = v;
  eraserSizeDisplay.textContent = v;
  if (isErasing) layers[activeIndex].ctx.lineWidth = v;
});

// イベントリスナーの処理はlayerごとに呼び出すことが必要
function setupEvents(layer) {
  const canvas = layer.canvas;
  const ctx    = layer.ctx;

  canvas._onMouseDown = function(e){
    // 押された時に書いてるよとフラグを立てる
    isDrawing = true;
    [lastX, lastY] = [e.offsetX, e.offsetY];
  };

  canvas._onMouseMove = function(e){
    // マウスが動いてる時常に（フラグが立っている時にisDrawingで限定）
    // カーソルのスクリプト
    // ① まず前回のプレビューを消す
    cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
    // ② 現在のモードとサイズを取得
    const size = isErasing
      ? parseInt(eraserWidthSlider.value, 10)
      : parseInt(brushWidthSlider.value, 10);
    const x = e.offsetX, y = e.offsetY;
    // ③ プレビューのスタイルを設定
    cursorCtx.lineWidth = 1;
    if (isErasing) {
      // 消しゴムモード：半透明グレーで枠だけ
      cursorCtx.strokeStyle = "rgba(0,0,0,0.3)";
    } else {
      // ペンモード：今の線色（不透明度込み）を使う
      cursorCtx.strokeStyle = ctx.strokeStyle;
    }
    // ④ 円を描く
    cursorCtx.beginPath();
    cursorCtx.arc(x, y, size / 2, 0, Math.PI * 2);
    cursorCtx.stroke();

    // 実際の描画のスクリプト
    // フラグが立っているので描画がなされる
    if (!isDrawing) return;
    ctx.lineWidth   = size;
    // ブラシ形状の再確認
    ctx.lineCap     = "round";
    ctx.lineJoin    = "round";
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
    [lastX, lastY] = [e.offsetX, e.offsetY];
  };

  // マウスを離すと書いてないよになってmousemoveが無効化される。カーソルも消す
  // アロー関数を使用(簡単な記法)
  canvas._onMouseUp    = () => isDrawing = false;
  canvas._onMouseLeave = () => {
    isDrawing = false;
    cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);
  };
}

// イベントリスナーを登録する関数
function attachDrawEvents(layer) {
  const canvas = layer.canvas;
  canvas.addEventListener("mousedown",  canvas._onMouseDown);
  canvas.addEventListener("mousemove",  canvas._onMouseMove);
  canvas.addEventListener("mouseup",    canvas._onMouseUp);
  canvas.addEventListener("mouseleave", canvas._onMouseLeave);
}

// イベントリスナーを削除する関数
function detachDrawEvents(layer) {
  const canvas = layer.canvas;
  canvas.removeEventListener("mousedown",  canvas._onMouseDown);
  canvas.removeEventListener("mousemove",  canvas._onMouseMove);
  canvas.removeEventListener("mouseup",    canvas._onMouseUp);
  canvas.removeEventListener("mouseleave", canvas._onMouseLeave);
  // 不要になった参照を削除
  delete canvas._onMouseDown;
  delete canvas._onMouseMove;
  delete canvas._onMouseUp;
  delete canvas._onMouseLeave;
}

  </script>

  <script>// カラーピッカーのスクリプト。
const colorInput = document.getElementById('color-picker');
const alphaInput = document.getElementById('alpha');
const alphaDisplay = document.getElementById('alpha-display');

//初期色設定。カラーコードを16進数から10進数に変案、不透明度と合成してrgbaにした後、
//現在アクティブなレイヤーの線色を変更※レイヤーがないとバグるので注意(エラーメッセージ実装を検討)
function updateBrushColor() {
  const hex = colorInput.value;
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  const a = alphaInput.value / 100;

  const rgba = `rgba(${r}, ${g}, ${b}, ${a})`;
  layers[activeIndex].ctx.strokeStyle = rgba;
  //document.getElementById("color-preview").style.backgroundColor = rgba;
}

// 色・不透明度の変更イベント
colorInput.addEventListener('input', updateBrushColor);
alphaInput.addEventListener('input', () => {
  alphaDisplay.textContent = alphaInput.value;
  updateBrushColor();
});

//キャンパスサイズを変更するスクリプト。wrapperに依存。フォルダ実装時にいじる必要あり。
function resizeCanvases() {
  const wrapper = document.getElementById('canvas-wrapper');
  const width = wrapper.clientWidth;
  const height = wrapper.clientHeight;

  const canvases = wrapper.querySelectorAll('canvas');
  canvases.forEach(canvas => {
    canvas.width = width;   // 描画解像度の設定（これがないとボケる）
    canvas.height = height;
  });
  cursorCanvas.width = wrapper.clientWidth;
  cursorCanvas.height = wrapper.clientHeight;

}
//この中はhtmlとcssが読み込み終了してから動く


</script>

<!--DOM取得に関わるコード-->
<script>
  window.addEventListener('load', () => {
  baseLayer = addLayer(wrapper, layers);
  applyBrushStyle(baseLayer.ctx);
  setupEvents(baseLayer);
  attachDrawEvents(baseLayer);
  resizeCanvases();
  updateBrushColor(); // カラーピッカーの初期化
});

//テスト。反映されてますか？？
</script>
</body>
</html>